module NIC (main, moduli) where

import Data.List
import System.Environment

moduli = map (2^64-) [0,3,5,7,9,11,15,17,33,35,39,45,47,53,57,59,63,75,77,83,87,89,95,99,105,113,117,119,125,129,143,147,153,155,165,173,179,183,189,195,197,209,215,243,249,255]

l19 = [176377839,381468772192258129,390125285764888664734203691,374033672392630508524864795662961961,359448796707478853662201398479404356886186983,345681908391253482444700805766256890688374132702150281,332456409626323552089753008110920578989152425860059980776167267,319736046569415960553023346593909692027276993628971883863936977542620829,307502197883843189728145070683195306634715300572715148091618574821423047802111371,295736438538105920753848805101221518347169034846464241638380603304292532634709193160046357,284420866155234999231087007390392444099790919003942969485429344438762552097336795489845181754603195,273538254349547522259589180544472876860684075817857666308521432524590908173589166299381140508333672348231869,263072036883964825093321085743751624592085890795667877968046914722839766002860060188356044538992936620738346077533371,253006281532576453382590877761237615086708861593042289202522301490010243250555590112007735795468718567589774511008063937101981,243325665673703086779483164699776334863653761239608010895221752077059186635289648588694650419857894777881877451704872426644446631397547,234015452963882018736875664431930231575827140398694847657266616194101746493170926436132593907169134296767239208215341305209205413117620066366669]

eqlyx (_,_,_,a) (_,_,_,b) = a==b

addyx m (i0,n0,l0,yx) (i1,n1,l1,_) = ((i0+i1) `mod` m,
                                      (n0+n1) `mod` m,
                                      (l0+l1) `mod` m, yx)

main = do [arg] <- getArgs
          let modulus = moduli !! read arg :: Integer
          print modulus
          inp <- getContents
          let cnts = [(read newill, read needy, read legal, read yx) |
                      line <- lines inp,
                      "newillegal" `isPrefixOf` line,
                      let (_:newill:_:needy:_:legal:_:yx:_) = words line] ::
                      [(Integer,Integer,Integer,(Int,Int))]
          let cumcnts = map (foldr1 (addyx modulus)) $ groupBy eqlyx cnts
          let cnt1 = map (\(i,n,l,yx) ->  i+n+l  `mod` modulus) cumcnts
          let cnt3 = map (\(i,n,l,yx) -> 3*(n+l) `mod` modulus) cumcnts
          let diffs = zipWith (\x y-> (x-y) `mod` modulus) cnt1 (3:cnt3)
          let check = zipWith (\(i,n,l,yx) d -> (i,n,l,yx,d)) cumcnts diffs
          mapM_ print check
          let rowlegal = [l | (i,n,l,(y,x))<-cumcnts, x==0]
          let check19 = zipWith (\x y-> (x-y) `mod` modulus) rowlegal l19
          mapM_ print $ zip [1..] check19
